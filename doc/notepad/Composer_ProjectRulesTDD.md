# R言語による生物情報学解析のためのテスト駆動開発（TDD）ガイド

#開発手法 #TDD #テスト #ガイドライン #rules_for_ai #composer #cursor #実践 #R #renv #roxygen2 #tidyverse #debugging #生物情報学 #RMarkdown #パイプライン #ワークフロー #FAIR #git #バージョン管理

> [!NOTE]
> このガイドはCursor Composerの機能を使ってR言語のTDDを実践するためのルール例です。
> 関連ガイド: [[Composer_インデックス]] | [[Composer_Rules_for_AI]] | [[Rules_for_AI_例]]

> [!TIP]
> 長くなった内容を以下の関連ファイルに分割しました。各トピックの詳細はリンク先をご覧ください：
> - 具体的な実装例： [[Composer_ProjectRules_Cursor実装例]]
> - ドキュメント例： [[Composer_ドキュメント例]]
> - テストとデバッグ例： [[Composer_テスト例とデバッグ例]]

## 1. 基本原則
- 常に実装コードの前にテストを書くこと
- Red-Green-Refactorサイクルに従うこと
  1. 失敗するテストを書く（Red）
  2. テストが通るように最小限の実装をする（Green）
  3. コードをリファクタリングする（Refactor）
- テストは具体的で意味のある簡潔なものであること

## 2. 開発環境とプロジェクト管理

### 2.1 パッケージ管理
- プロジェクトのパッケージ管理には`renv`を使用する
- 新しいパッケージを追加した場合は必ず`renv::snapshot()`を実行する
- プロジェクトの初期セットアップ時に必ず`renv::restore()`を実行する
- `tests/testthat.R`ファイルの先頭で`renv::load()`を呼び出し、テスト環境が正しく設定する
- CIパイプラインでは、テスト実行前に`renv::restore()`を実行する設定を行う

### 2.2 コマンド一覧
- テスト実行: `devtools::test()` または `testthat::test_dir("tests/")`
- カバレッジ確認: `covr::package_coverage()` または `covr::report()`
- 環境設定: 初回実行時・環境変更時に `renv::restore()`
- スタイルチェック: `styler::style_pkg()` や `lintr::lint_package()`

## 3. コーディング規約

### 3.1 基本スタイル
- 基本的に**tidyverseスタイルガイド**に従ってコードを書く
  - 変数名はスネークケース（`lower_case_with_underscores`）を使用
  - スペース: `=`、演算子、カンマの後にはスペースを入れる
  - インデント: 2スペースを使用、タブは使用しない
  - 行の長さは80文字以内に収める

### 3.2 生物情報学固有のルール
- 生物情報学系パッケージを利用する場合は**Bioconductor規約**に従う
  - クラス名はキャメルケース（`CamelCase`）
  - メソッド名は小文字で始まるキャメルケース（`camelCase`）
  - Bioconductorパッケージとの互換性を優先する

### 3.3 ドキュメンテーション
- すべての関数には**roxygen2**形式のドキュメントを記述する
- 必須ドキュメント要素:
  - `@title`: 関数の簡潔な説明
  - `@description`: 関数の詳細な説明
  - `@param`: 各パラメータの説明
  - `@return`: 戻り値の説明
  - `@examples`: 使用例（可能な場合）
- パッケージ全体の文書化には`DESCRIPTION`ファイルと`vignettes/`を使用する

## 4. テスト作成と実装

### 4.1 テストプロセス
- 期待される動作を明確に記述した失敗するテストから始める
- テストを通すための最小限の実装を行う
- テストが通る状態を維持しながらコードをリファクタリングする
- さらに機能を追加するために追加のテストを書く

### 4.2 テスト実装方針
- ユニットテストには`testthat`パッケージを使用する
- `covr`パッケージでコードカバレッジを測定する
- 外部依存関係は`mockery`や`mockr`パッケージでモック化する
- エッジケースとエラー条件をテストする
- 実装の詳細ではなく、動作に焦点を当ててテストする

### 4.3 コード品質基準
- テストカバレッジを80%以上に維持する
- テスト対象を明確に説明するテスト名を使用する
- context()関数を使用して関連するテストをグループ化する
- テスト間の依存関係を防ぐためにテストを分離する

> [!TIP]
> テスト実装の具体例は [[Composer_テスト例とデバッグ例]] を参照してください。

## 5. デバッグとロギング

### 5.1 基本方針
- プロジェクト内では**futile.logger**と**cli**の組み合わせを使用する
  - `futile.logger`: 内部処理のログ記録用
  - `cli`: ユーザーインターフェース用の出力フォーマット

### 5.2 futile.loggerの使用ルール
- 適切なログレベルを使用する
  - TRACE: 非常に詳細なデバッグ情報（通常はコメントアウト）
  - DEBUG: 開発中の詳細なデバッグ情報
  - INFO: 通常の実行でも有用な一般的な情報
  - WARN: 致命的ではないが注意すべき状況
  - ERROR: 処理が正常に完了できない問題
  - FATAL: プログラム全体が終了するような重大な問題
- プロジェクト内で一貫したログ出力先を設定する
  - 長時間実行される解析：ファイル出力を設定
  - インタラクティブな処理：コンソール出力を使用
- 複雑な解析パイプラインでは名前空間を活用する

### 5.3 cliの使用ルール
- ユーザーに表示する情報には`cli`を使用
- 進捗状況の表示には`cli_progress_bar`を使用
- 情報の種類に応じた適切なアラート関数を使用する
  - `cli_alert_info`: 一般情報
  - `cli_alert_success`: 正常終了
  - `cli_alert_warning`: 警告
  - `cli_alert_danger`: エラー
- セクション分けには見出し関数（`cli_h1`, `cli_h2`など）を使用

### 5.4 注意点
- メモリ使用量の多い操作では過剰なロギングを避ける
- 大規模なオブジェクト（特にscRNA-seqデータなど）の内容を直接ログに記録しない
  - 代わりに要約統計量や次元情報のみを記録
- ループ内では必要最小限のロギングにとどめる
  - 反復回数が多い場合は、一定間隔（例：10%ごと）でのみログを記録
- テスト実行中はデフォルトでWARNレベル以上のみ表示するよう設定

> [!TIP]
> デバッグとロギングの具体例は [[Composer_テスト例とデバッグ例]] を参照してください。

## 6. 実装例と参考情報

具体的な実装例については、以下の分割ファイルを参照してください：

- **Cursorでの実装例**: [[Composer_ProjectRules_Cursor実装例]]
  - Cursorでのルール設定方法
  - Composerプロンプト例
  - Rules for AIの活用例

- **ドキュメント例**: [[Composer_ドキュメント例]]
  - roxygen2ドキュメント例
  - R Markdownドキュメント例
  - ISA-Tab形式メタデータ例
  - BioComputeObject (BCO)例
  - Snakemakeワークフロー例
  - ディレクトリ構造例

- **テストとデバッグ例**: [[Composer_テスト例とデバッグ例]]
  - 基本的なテスト例
  - モックを使ったテスト
  - 例外テスト
  - futile.loggerの使用例
  - cliを使ったユーザーインターフェース例
  - 大規模データの効率的なロギング

## 7. ドキュメント作成規格

### 7.1 RNA-seq解析ドキュメントの基本原則

- **再現性**を最優先し、全ての解析ステップを明示的に記録する
- **FAIR原則**（Findable, Accessible, Interoperable, Reusable）に準拠する
- 複雑なワークフローは視覚的に表現する
- コードとドキュメントを一体化し、自己文書化を促進する
- 実験デザインとパラメータ選択の根拠を明記する

### 7.2 推奨ドキュメントフォーマット

- **R Markdown/Jupyter Notebook**: 各解析ステップの記録
- **ワークフロー記述言語**: Snakemake, Nextflow, WDL/CWL
- **BioComputeObject (BCO)**: 規制対応が必要な研究向け

> [!TIP]
> 各フォーマットの具体例と実装方法については [[Composer_ドキュメント例]] を参照してください。

### 7.3 メタデータと実験デザイン記述

- サンプル情報と実験デザインはISA-Tab形式で記述
- Gene Expression Omnibus (GEO)提出用のメタデータシートを作成
- MIAMEガイドラインに準拠した最低限必要な情報を記録

### 7.4 バージョン管理と追跡性

- Gitでコードを管理（`.gitignore`でデータファイルは除外）
- 大規模データファイルはDVC (Data Version Control)で追跡
- 解析環境の再現性は`renv`で確保
- 解析実行時の環境情報を自動的に記録

### 7.5 ディレクトリ構造

RNA-seqプロジェクトの標準的なディレクトリ構造については、[[Composer_ドキュメント例]] を参照してください。

## 8. Gitによるバージョン管理

### 8.1 基本方針

- すべてのソースコードはGitで管理し、定期的にリモートリポジトリにプッシュする
- 大規模なデータファイルは`.gitignore`で除外し、必要に応じてDVC (Data Version Control)で管理
- コード変更はコミット前に必ずテストを実行し、テストが通ることを確認する
- 各機能開発・バグ修正は個別のブランチで行い、Pull Requestを通じてマージする
- バージョンタグは[セマンティックバージョニング](https://semver.org/)に従って付与する（例: v1.0.0）

### 8.2 ブランチ戦略

- **main**: 常に安定したリリース可能な状態を維持
- **develop**: 開発用ブランチ、次回リリースの変更がマージされる
- **feature/\***: 新機能開発用ブランチ（例: feature/add-deseq2-analysis）
- **fix/\***: バグ修正用ブランチ（例: fix/normalization-error）
- **release/\***: リリース準備用ブランチ（例: release/v1.2.0）
- **hotfix/\***: 緊急バグ修正用ブランチ（例: hotfix/critical-data-loss）

### 8.3 コミットメッセージ規約

コミットメッセージは以下のフォーマットに従う：

```
git commit -m "{{タイプ}}: {{タイトル}}" -m "{{本文}}"
```

#### タイプ一覧

- **feat**: 新機能の追加
- **fix**: バグ修正
- **docs**: ドキュメント変更のみ
- **style**: コードスタイル変更（ロジック変更なし）
- **refactor**: リファクタリング（機能追加・バグ修正なし）
- **perf**: パフォーマンス改善
- **test**: テスト追加・修正
- **chore**: ビルド・ツール関連の変更

#### メッセージ作成のポイント

- 日本語で記述
- 変更内容を簡潔に要約
- 主要な変更点と目的を明確に
- 必要に応じて箇条書きを使用
- ファイル履歴は含めない

### 8.4 Pull Request規約

Pull Requestは以下のフォーマットに従って作成する：

```
gh pr create \
  --draft \
  --title "{{PRタイトル}}" \
  --body "## 概要
{{概要}}

### 関連 Issue/ドキュメント
- {{#ISSUE番号}}

### 変更内容
- {{変更内容}}

## レビュアーに特に見て欲しいところ
- {{レビュアーに特に見て欲しいところ}}

## 影響範囲
- {{影響範囲}}

## 動作確認手順
{{動作確認手順}}"
```

#### PRのポイント

- コードレビューを受ける前にセルフレビューを行う
- 各PRは単一の論理的変更に集中させる
- PR説明には変更の目的と影響範囲を明記する
- R言語特有の注意点（パッケージバージョンなど）を記載する
- 長期間作業しているブランチは頻繁に最新のdevelopブランチをマージする

### 8.5 R特有のバージョン管理ポイント

- パッケージ依存関係の変更は必ず`DESCRIPTION`ファイルと`renv.lock`に反映させる
- データ解析スクリプトの変更はR Markdownのセッション情報も更新する
- バイオコンダクターパッケージのバージョンは半年ごとのリリースサイクルを考慮する
- 解析再現性のために環境情報を`.Rprofile`で管理し、Gitで追跡する
- パッケージ開発の場合は`NEWS.md`ファイルで変更履歴を記録する

### 8.6 バージョニングとリリース

- メジャーバージョン（1.0.0): 後方互換性のない変更
- マイナーバージョン（0.1.0): 後方互換性のある機能追加
- パッチバージョン（0.0.1): バグ修正や小さな変更
- プレリリース版は接尾辞を使用（例: v1.0.0-beta.1）

リリース時には以下を実施:
- `NEWS.md`や`CHANGELOG.md`の更新
- バージョン番号の更新（`DESCRIPTION`ファイル）
- テストの全実行と確認
- タグ付け（`git tag -a v1.0.0 -m "バージョン1.0.0リリース"`）

## 9. Cursorでの設定方法

Cursorでプロジェクトルールを適用するには、`.cursor/rules`ディレクトリにルールファイルを作成します。このファイルにはTDDとドキュメント作成の規約を記述し、R言語とR Markdownファイルに適用します。

設定ファイルは以下の要素で構成されます：
- メタデータ: Description, Globsパターン
- ルールセクション: 基本原則、コーディングスタイル、ドキュメント標準など

> [!TIP]
> 具体的な設定方法やファイル例については [[Composer_ProjectRules_Cursor実装例]] を参照してください。

このルールをCursorで適用することで、チーム全体が一貫したTDDプラクティスとドキュメント規格に従うことができます。また、Composerと組み合わせることで、AIアシスタントもこのルールに準拠したコードやドキュメントを提案できるようになります。 